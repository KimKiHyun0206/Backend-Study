# 서브 클래싱과 서브 타이핑
### 상속의 용도
* 계층을 구현하는 것
* 코드의 재사용
> 상속은 코드의 재사용보다는 계층을 구현하기 위해 사용하는 것이 좋다

# 타입
* `심볼` : 타입에 이름을 붙인 것
* `내연` : 타입 안에 속하는 개념들의 공통된 속성이나 행동
* `외연` : 타입에 속하는 객체들의 집합
### 슈퍼타입
* 집합이 다른 집합의 모든 멤버를 포함한다
* 타입 정의가 다른 타입보다 일반적이다
## 서브타입
* 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다
* 타입 정의가 다른 타입보다 더 구체적이다

# 상속을 사용해야하는 경우
### IS-A 관계를 만족시킬 때
단순히 코드의 재사용이 목적이 아니라 계층관계를 나타내기 위해서 상속을 하는데 이때 이 관계를 만족시켜야 상속 후보로 생각할 수 있다
    
    Bus is a Car
    Taxi is a Car
### 행동 호환성이 맞을 때
행동 호환성이란 그 클래스를 사용할 클라이언트가 부모와 자식의 차이를 몰라야 한다는 것이다

    public interface Car{
        void 주행();
    }

### ISP, 인터페이스 분리의 법칙을 이용할 경우

    interface Marking;
    interface Memo;
    
    public class MarkingPen implements Marking, Memo {

    }

# 서브클래싱
다른 클래스의 코드를 재사용할 목적으로 상속을 하는 경우를 가리킨다
* `구현 상속` `클래스 상속` 이라고 부르기도 한다

# 서브타이핑
타입 계층을 구성하기 위해 상속을 사용하는 경우
* 인터페이스 상속이라고 부르기도 한다


    예제 코드
    public interface Pen;

    public class MarkingPen implements Pen
    public class FountainPen implements Pen

## 대체 가능성
서브타이핑 관계가 유지되기 위해서는 `행동 호환성`을 만족시켜야 한다. 이를 만족시켜야만 자식 클래스가 부모 클래스를 대체할 수 있게 된다.

## LSP, 리스코브 치환 원칙
> 자식 클래스는 부모 클래스를 대체할 수 있어야 한다

이는 두 클래스가 서브타이핑 관계를 만족시키기 위한 조건이다.

* 이어폰 > 갤럭시 버즈, 아이팟
* 핸드폰 > 갤럭시, 아이폰
* 우유 > 딸기우유, 바나나우유

### 리스코브 치환 원칙은 유연한 설계를 위한 방법이다
부모 대신 자식이 일을 수행할 수 있다는 것만 보더라도 유연한 설계가 가능해진다

# 계약에 의한 설계와 서브타이핑
* `사전조건` : 메소드의 매개변수
* `사후조건` : 리턴타입
* `클래스 불변식` : 메소드 실행 전과 메소드 실행 후에 인스턴스가 만족시켜야 하는 것

이 계약을 표현하기 위해 인터페이스를 사용한다
    
    interface Tax {
        void pay(int amount, Policy policy);
    }
