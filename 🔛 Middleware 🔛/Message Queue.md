# Message Queue

> 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중 하나.
> 메시지 지향 메들웨어를 구현한 시스템을 의미한다

* `Message Oriented Middleware` : MOM
* `메시지 지향 미들웨어` : 비동기 메시지를 사용하는 응용 프로그램들 사이에서 데이터를 송수신하는 것
* `메시지` : 요청, 응답, 오류 메시지, 단순한 정보, 작은 데이터

<br>

![img.png](../🔲%20Image%20🔲/리펙토링 이전의 이미지/img6/Message%20Queue.png)

> 메시지 큐는 메시지를 임시로 저장하는 간단한 버퍼라고 생각하면 된다.
> 메시지를 전송 및 수신하기 위해 중간에 메시지 큐를 두는 것이다

* `생산자(Producer)` : 생산자로 취급되는 컴포넌트가 메시지를 메시지 큐에 추가한다
* `소비자(Consumer)` : 소비자로 취급되는 컴포넌트가 메시지를 검색하고 이를 사용하여 어떤 작업을 수행할 때까지 큐에 저장된다
* `One-to-One 통신` : 각 메시지는 하나의 소비자에 의해 한 번만 처리될 수 있따

<br>

# 언제 메세지 큐를 사용할까?

> 실패하면 치명적인 핵심 작업 보다는 어플리케이션의 부가적인 기능에 사용하는 것이 적합하다.

## 이메일 전송

> 어느 정도의 응답 지연이 허용되며, 어플리캐이션의 랙심 기능은 아닌 경우이므로 이 경우 사용될 수 있다

![img.png](../🔲%20Image%20🔲/리펙토링 이전의 이미지/img6/Message%20Qqeue-Email.png)

* 비밀번호 재설정을 위해 이메일을 발급하는 서비스, 회원 가입을 위해 이메일을 발급하는 서비스 등은 메시지(Email)를 큐에 넣을 수 있다
* 이메일이 어느 서비스부터 생산되었는지와 완계 없이, 메시지 큐의 메시지를 하나씩 소비하고, 그저 이메일이 전송되어야 할 곳으로 이메일을 전송한다

> #### 뛰어난 화갖ㅇ성
> 메시지 큐에 들어오는 메시지 수가 너무 많아지는 경우 이메일 전송 전용 서비스 인턴스를 더 둠으로써 확장할 수 있다

## 블로그 포스팅

> 블로그에 작은 이미지 파일만 있는 것이 아닐 수 있다. 이럴 때 이미지 파일의 크기가 적은 것 먼저 가져오고
> 큰 것은 나중에 가져옴으로써 사용자가 블로그의 내용을 완전하진 않더라도 볼 수 있도록 한다.

* 서비스의 응답 시간을 저해하지 않으면서 사용자들에게 유연성을 제공하는 방법
* 이미지를 즉각 처리하는 것이 아닌, 사후처리하며 최적화하는 방법
* 사용자 경험에 영향을 미칠 수 있다
* 최적화는 응용 프로그램에서 가장 중요한 것은 아니며, 작업을 즉시 수행할 필요도 없다

#### 사용 예시

1. 사용자가 고용량의 이미지가 포함된 블로그 포스팅
2. 이미지는 저장소에 전송
3. 업로드된 이미지에 대한 정보가 포함된 메시지를 이미 최적화 서비스의 메시지 큐에 담는다
4. 이미지 최적화 서비스는 저장소에서 이미지를 가져와 최적화하고, 2번에서 젖아해놨던 이미지를 대체한다

### Message Queue 의 특징

> 소비자가 실제로 메시지를 어느 시점에 가져가서 처리하는지 보장하지 않는다

* `비동기적 특성` : 언젠가는 큐에 넣어둔 메시지가 소비되어 처리될 것이라고 믿는다
* 실패하면 치명적인 핵심 작업보다는 어플리케이션의 부가적인 기능에 사용하는 것이 적합하다

### 올바르지 않은 사용

* `Client-Server 구조` : 사용자가 요청을 하면 서버는 그에 대한 처리를 한 후 클라이언트에 응답한다
    * `HTTP 요청` : 사용자가 응답을 기다려야 하는 요청을 바로 처리하지 않고 중간에 메시지 큐를 두는 것은 바람직하지 않다

### 사용 방법

1. 다양한 메시지 큐 중에서 시스템의 목적에 맞는 것을 선정해야 한다
2. 선정된 메시지 큐의 사용 방법을 익힌다
3. 지원하는 다양한 옵션 중에 시스템이 추구하는 목적에 맞는 옵션을 찾아 설정해야 한다

<br>

# 메시지 큐의 이점

### 비동기, Asynchronous

> 메시지 큐는 생산되 메시지의 저장, 전송에 대해 동기화 처리를 진행하지 않는다.

* 큐에 넣어두기 때문에 나중에 처리할 수 있따
* 기존 동기화 방식은 많은 메시지(데이터)가 전송될 경우 병목이 생길 수 있다
    * 이후에 들어오는 요청에 대한 응답이 지연될 것이다

### 낮은 결합도, Decoupling

> 생산자 서비스와 소비자 서비스가 독립적으로 행동한다

* 서비스 간의 결합도가 낮아진다

### 확장성, Scalable

> 생산자 서비스 혹은 소비자 서비스를 원하는대로 확장할 수 있다

### 단력성, Resilience

> 문제가 발생하더라고 메시지는 메시지 큐에 남아있다

* 소비자 서비스가 다운되더라도 어플리케이션이 중단되는 것은 아니다
* 메시지는 큐에 남아있기 때문에 소비자 서비스가 다시 시작될 때마다 추가 설정이나 작업을 수행하지 않고도 메시지를 처리할 수 있다

### 보장성, Guarantees

> 메시지 큐는 큐에 보관되는 모든 메시지가 결국 소비자 서비스에게 전달된다는 일반적인 보장을 제공한다

* 중간에 메시지가 사라지지 않는다

<br>

# 메시지 큐의 종류

* RabbitMQ
* Kafka
* ActiveMQ
* etc...

<br>

---
#### 🔗
* [메세지 큐란?](https://tecoble.techcourse.co.kr/post/2021-09-19-message-queue/)