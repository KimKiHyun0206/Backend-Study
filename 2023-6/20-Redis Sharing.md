# Redis Sharding, 레디스 샤딩

* Replication 은 모든 데이터를 복제해야 하기 때문에 단일 서버에서 저장 가능한 양을 초과하면 이를 복제할 수 없다
* 따라서 메모리 증설 등을 통한 Scale-Up 만으로 데이터 저장 공간을 확보할 수 없다면 다른 방법이 필요하다

# Partitioning 개념

> DB의 관리 용이성 및 읽기 최적화를 위해 논리적인 테이블의 물리 구조를 여러 개의 파티션(Partition)으로 분할하여 분산 저장하는 기법

| ID  | 이름  | 나이  |  생일   |
|:---:|:---:|:---:|:-----:|
|  1  |  김  | 22  | 0206  |
|  2  |  이  | 21  | 1010  |
|  3  |  박  | 23  | 0123  |
|  4  |  황  | 20  | 0526  |
|  5  |  김  | 24  | 0417  |

* 위와 같은 테이블이 있다
* 이때 가입자가 계속 증가하여 테이블의 크기가 커진다면, 해당 테이블의 조회 성능을 높이기 위해 인덱스 추가 등의 작업을 한다
* 하지만 이 작업은 쉽지 않으며, 점차 조회 성능도 떨어지게 된다

<br>

> 이런 경우에 사용자에게 논리적으로 보여지는 테이블은 하나지만 물리적으로는 여러 파티션에 데이터를 나누어 저장하면 조회 성능 향상 및 관리가 용이해진다

### 이점

* 생일을 기준으로 삭제한다면 하나하나 찾아야겠지만 월별로 나누어 저장한 경우에는 삭제가 쉬워진다
* 한 파티션만 Drop 하면 되기 때문이다
* 반대로 특정 월에 해당하는 데이터를 조회할 때, 해당 파티션에 속한 데이터만 조회하면 되기 때문에 인덱스를 사용하는 방법보다 빠른 조회가 가능하다

> 대용량의 논리적 구조를 여러 물리적인 파티션으로 분할하여 조회 및 관리 용이성을 위해 사용한다

<br>

# Partitioning 종류

> 수직적 and 수평적

## 수평적

> 특정 데이터를 기준으로 데이터를 다른 파티션에 저장하는 방법

* 성씨 / 생년월 / 나이 범위 등으로 나눈다

## 수직적

> 특정 컬럼을 기준으로 데이터를 분할한다

* 정규화할 때 컬럼을 기준으로 나누는데, 그런 방법으로 나눈다고 생각하면 된다.
* `이점` : 한쪽 세그먼트에서 발생하는 DML 이 다른 쪽에 영향을 끼치지 않는다.
* 레코드 전체 데이터를 읽어야 할 경우에는 데이터가 물리적으로 분산되어 있으므로 비효율적이다

## NoSQL 의 Sharding

> 수평적 파티셔닝의 한 종류

* 수평적 파티셔닝과 비교하여 다른 점은 파티셔닝은 단일 DBMS 내에서의 데이터 분할 정책이고, 샤딩은 분할된 여러 데이터베이스 서러보 데이터를 분할하는 방법이다
* 샤딩을 구성하게 되면 샤드의 수만큼 노드가 존재하며, 서버가 여러 개 존재하므로 부하를 적절히 분산할 수 있다

> 용량을 고려하여 데이터 크기를 분할할 때, 수직적 파티션보다는 수평적 파티션이 분배에 용이하다.

<br>

# Partitioning 전략 - 수평적

> 특정 범위를 기준으로 데이터를 분할한다

* 이를 **Range Partition** 이라고 한다
* `장점` : 논리적인 범위의 분산에 효율적 and 원하는 데이터가 특정 파티션에 모여있어 관리하기 용이
* `단점` : 데이터의 분포가 고르지 못할 경우 데이터 배분을 균등하게 할 수 없다
* 데이터 균등 분배를 위해 해쉬 전략을 사용한다

## Hash Partitioning

> Redis 의 Key 값에 대하여 Hash 함수를 적용한 결과 Redis Master 의 개수만큼
> 나머지 연산을 토대로 데이터를 저장할 Master 서버를 지정하는 것.

* 장점 : Modulo 연산을 통해 데이터의 분포 여부와 상관없이 고르게 분포시킬 수 있다.

```
Maste가 3대 있다.
master 1 -> index 0
master 2 -> index 1
master 3 -> index 2
```

```java
public class HashSample {
    public static void main(String[] args) {
        var hosts = Arrays.asList(Master1, Master2, Master3);
        var index = hash(key) % host.size();
        var target = hosts.get(index);
    }
}
```

* 이때 Redis Key 에 대하여 Hash 함수를 적용한 결과가 1934라면 1934 % 3(서버의 개수)의 결과인 2에 해당하는 Master3 의 노드가 해당 Key의 저장소이다
* 데이터를 조회할 때도 Client는 해당 저장소에서 데이터를 찾으려고 할 것이다

## Rebalancing 문제

> 만약 Hash Partitioning이 적용된 상황에서 데이터 용량이 더 커져 Master 서버를 추가해야 한다면,
> 어떤 이슈가 존재할까

#### 가정 1

* 총 12개의 데이터가 3 개의 Master에 고르게 분배되어 있다
* 위와 같은 상황에서 Hash 함수 결과가 9를 저장하고 있는 Master는 1번 Master가 선택될 것이다.
* Client는 해당 연산을 통해서 Master 1에 질의할 것이다

#### 가정 2

* Master 4를 새롭게 추가한다
* 이 상황에서 기존과 같이 Hash 함수 9의 결과를 가진 Redis 서버를 찾고자 하면 어떤 일이 생길까?
* 9 % 4 = 1 -> 잘못된 서버에 질의를 하게 된다
* 따라서 서버를 추가할 경우에는 그에 맞게 데이터를 재분배(Rebalancing)작업이 필요하다

<br>

* 재분배 작업을 통해 75% 의 데이터가 다른 노드로 이동한다
* 데이터를 재분배 하는 과정에서 굉장히 많은 부하가 발생할 수 있다
* 운영 중에 노드 추가 작업이 자유롭지 못하다

<br>

## Consistent Hashing

> 데이터와 더불어 Master 서버에 대하여 동일한 해시 함수를 적용하고,
> Master 서버 해시값 구간에 해당되는 데이터를 저장한다

* Rebalancing 부하를 줄이기 위해서 재분배되는 데이터 양이 적어야 한다

<br>

|   노드    |        데이터 담당 범위         |
|:-------:|:------------------------:|
| Master1 | 해시값 <= 500 or 해시값 > 2121 |
| Master2 |    501 < 해시값 <=  1000    |
| Master3 |      1 < 해시값 <= 741      |
| Master4 |    741 < 해시값 <= 1121     |


* Redis Master 서버에 대하여 해시 함수가 적용된 700인 데이터가 입력되었다
* 이는 501보다 크고 1000보다 작으므로 Master 2 노드가 해당한다
* 이렇게 Consistent Hashing 기법에서는 서버를 추가하면서 해시 함수를 적용하여 Hash Ring 상태로 만든다
* 이후 입력되는 데이터는 해시 값 결과에 따라 저장소가 결정된다

### 정리
* 해시 파티셔닝을 사용함 -> 데이터 균등하게 분포
* 데이터 재분배에 대한 영향도를 최소화 : Consistent Hashing 알고리즘 이용
* Consistent Hashing 알고리즘 사용시 고려 사항은 Hash Ring 에 가상 노드를 촘촘하게 그리고 노드가 간격을 균일하게 배치할 수 있도록 Hash 알고리즘이 적용되어야 한다
* 특정 노드 간의 범위가 벌어짐 = 그만큼 재분배해야 할 데이터의 양이 많아진다


---
#### 🔗
* [참고1](https://cla9.tistory.com/102)