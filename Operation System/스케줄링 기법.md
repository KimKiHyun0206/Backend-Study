# 스케줄링

* 운영체제는 CPU를 프로세스 간에 교환함으로써, 컴퓨터를 보다 생산적으로 만든다
* 프로세스가 I/O 작업을 할 때 그 잠깐 동안은 CPU 를 사용하지 않는다. 이때 다른 프로세스가 CPU 를 사용할 수 있게 해준다

# 스케줄링 기준

### CPU utilization, CPU 이용률

* 0~100% 까지 이른다
* 실제로는 40~90% 정도의 범위를 가져야 한다

### Throughput, 처리량

* 단위 시간당 완료된 프로세스의 개수
* 긴 프로세스의 경우 이 비율은 몇 초 동안 동일한 프로세스가 될 수 있다
* 짧은 프로세스의 경우 처리량은 초당 수십개가 될 수도 있다

### Turnaround Time, 총처리 시간

* 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다
* 이것은 준비 큐에서 대기한 시간, CPU 에서 실행하는 시간, I/O 작업을 합한 시간이다

### Waiting Time, 대기 시간

* 준비 큐에서 대기하면서 보낸 시간의 합
* 스케줄링 알고리즘은 프로세스가 실행하거나 I/O 작업을 하는 시간의 길이에 영향을 미치지 않는다

### Response Time, 응답 시간

* 요구를 제출한 후 첫 번째 응답이 나올 때까지 걸리는 시간
* 응답이 시작되는 데까지 걸리는 시간이지, 그 응답을 출력하는데 걸리는 시간은 아니다.

# 스케줄링 알고리즘

CPU 스케줄링은 준비 큐에 있는 어느 프로세스를 CPU 코어에 할당할 것인지를 설정하는 문제를 다룬다

<br>

## 선입선출 스케줄링, First-Come-First-Out Scheduling

* 선입 선처리 스케줄링
* 선입 선처리 스케줄링은 FIFO Queue로 간단하게 구현할 수 있다
* 다른 말로 비선점형 스케줄링이라고도 한다

```java
class Scheduler {
    Queue<Process> readyQueue = new LinkedList<>();
}
```

### 장점

구현하기 쉽다

### 단점

* 평균 대기시간이 굉장히 길 수도 있다
* 왜냐하면 먼저 들어온 프로세스가 처리시간이 오래 걸리는 것이라면 그 프로세스를 완료해야만 다음 프로세스를 진행할 수 있기 때문이다

<br>

| 프로세스 |버스트 시간|
|:--:|:---:|
| P1 | 30 |
| P2 | 5 |
| P3 | 2 |

* 버스트 : 특정 기준에 따라 한 단위로서 취급되는 연속된 신호나 데이터의 모임
* CPU 버스트 : 프로세스가 CPU를 사용할때를 CPU버스트
* P2 = 30을 기다려야 한다
* P3 = 35를 기다려야 한다

이처럼 버스트 타임이 길어지면 효율이 떨어지게 된다

* 호위 효과 : 다른 모든 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것
    * 이 효과는 짧은 프로세스들이 먼저 처리될 때모다 CPU와 장치 이용률이 떨어지는 결과를 낳는다

## 최단 작업 우선 스케줄링, Shortest-Job-First Scheduling

* SJF Scheduling
* 각 프로세스에 CPU 버스트 길이를 연관시긴다.
* CPU가 이용 가능할 때 버스트 길이가 가장 짧은 프로세스를 할당한다
* 두 프로세스의 길이가 같으면 FIFO 기법을 이용해서 둘 중 하나를 선택한다
* Shortest-Next-SPU-burst

### 장점

* 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가진다
* Optimal = 최적이다

### 단점

* 다음 CPU 버스트 길이를 알 방법이 없기 때문에 CPU 스케줄링으로 구현할 수 없다
  <br>

| 프로세스 | 버스트 시간 |
|:--:|:------:|
| P1 | 6|
| P2 | 8|
| P3 | 5|
| P4 | 10|

이처럼 준비 큐에 있을 때 실행 순서는 `3 - 1 - 2 - 4` 이다.

## 라운드 로빈 스케줄링, Round-Robin Scheduling

* RR Scheduling
* 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.
* 시간 할당량 or 타입슬라이스 라는 작은 단위를 정의한다
* 선점형 스케줄링
* Context Switch을 고려해야 한다

| 프로세스 | 버스트 시간 |
|:--:|:------:|
| P1 | 24|
| P2 | 3|
| P3 | 3|
시간 할당향 = 4

<BR>

| 실행되는 프로세스 | P1  | P2  | P3  | P1  | P1  | P1  | P1  | P1  |
|:---------:|-----|-----|-----|-----|-----|-----|-----|-----|
|  버스트 타임   | 4   | 7   | 10  | 14  | 18  | 22  | 26  | 30  |

이렇게 시간 할당량이 끝날 때마다 이 프로세스보다 짧은 프로세스가 있나 없나 검사하고. 있다면 그 프로세스를 먼저 실행시키는 것이다.

* 만약 시간 할당량보다 프로세스의 버스트 길이가 짧다면 남은 시간은 기다리지 않고 방출해버린다

## 우선순위 스케줄링

* 프로세스에 우선순위를 두고 우선순위를 기준으로 스케줄링하는 것이다.
* 우선순위가 같은 것은 FCFS(선입 선처리)로 처리
* 우선순위가 다를 경우 우선순위에 따라 스케줄링

| 프로세스 | 버스트 시간 | 도착시간 |
|:----:|:------:|:----:|
|  P1  |   10   |  3   |
|  P2  |   1    |  1   |
|  P3  |   2    |  4   |
|  P4  |   1    |  5   |
|  P5  |   5    |  2   |

이처럼 스케줄링을 하면 다음과 같이 스케줄링 된다

```
P2   P5   P1   P3   P4
```

이 스케줄링은 버스트 시간에 따라서 스케줄링되었다.

### 문제점

우선순위 스케줄링은 기본적으로 무한봉쇄 또는 기아상태를 발생시킨다.

#### 기아 상태, Starvation

실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스

* 우선순위가 낮아서 무한히 기다리게될 때 발생한다
* 이를 해결하기 위해서 노화(Aging)이라는 방법을 사용한다

#### 노화, Aging

준비 큐에서 대기하는 프로세스들의 우선순위를 한 단계씩 높여주는 것이다.

* 이렇게 하면 우선순위가 낮은 프로세스라도 기아상태에서 빠져나올 수 있게 된다.

#### Foreground(대화형) 프로세스와 Background(배치) 프로세스

* `Foreground` : 우선순위가 높은 프로세스들이 들어간다
* `Background` : 우선순위가 낮은 프로세스들이 들어간다
* Foreground : Background = 8 : 2 정도의 비율로 프로세스를 진행시킨다
* 이를 통하여 기아현상을 해결한다

